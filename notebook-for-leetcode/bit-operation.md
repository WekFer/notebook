# 位运算笔记，以及代数范式（一种简易的有限状态机）

## 异或运算【^】

同类题目：
* [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)
* [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)
* [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii)
* [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

### 只出现一次的数字

**题目描述：「给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。」**

这里可以利用异或运算【^】的性质：
* x ^ x = 0;
* 0 ^ a = a ^ 0 = a;
* 交换律和结合律。（注：可以证明，如果某个二元运算满足交换律和结合律，则对于有限个元素和这个二元运算组成的公式，任意调换顺序和加括号不会改变最终结果。我不会证，就这样默认吧。）

这样一来，只要把数组中所有元素依次进行异或运算：
* 所有出现 **【两次】** 的元素情侣都会 ~~（单身狗狂喜地）~~ 抵消成 0，
* 而唯一一个出现 **【一次】** 的元素会作为单身狗在运算结果中剩下来。

这道题目就解决了。

### 丢失的数字

**题目描述：「给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。」**

输入：nums = [0,1]  
输出：2  
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。  

这道题的巧妙做法是，给这个数组附加上完整的 [0, n] 共 n + 1 个数，这样一来，丢失的数出现【一次】，其他数出现【两次】，就还原成上面那道题了。

### 只出现一次的数字 II

**题目描述：「给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。」**

这道题利用的不是单纯的异或运算。直接用【只出现一次的数字】中的做法，显然是不行的。  
我们需要改变思路。【只出现一次的数字】中的异或运算，除了利用异或运算的性质理解，还可以理解成模 2 的加法：

* 对于二进制表示的第 k 个位置，所有出现 **【两次】** 的元素，要么出现两次 0，要么出现两次 1，对于模 2 的加法来说，加起来结果都为 0；
* 而唯一一个出现 **【一次】** 的元素，如果出现 0，那么结果为 0，如果出现 1，那么结果为 1。最终结果会在二进制表示的各个位置上用 1 和 0 拼成这个出现一次的元素。

那么，如果我们可以设计出可以储存模 3 加法的状态规则，来统计每一位上出现 1 的个数，那么所有元素「加」起来的最终结果实际上就是唯一出现一次的元素。
自然的想法是：用三个数来分别表示 1 的个数模 3 余 0、模 3 余 1、模 3 余 2 的结果，不妨初始化为：

```
int zero = -1, one = 0, two = 0; 
//在补码的规则下，-1 表示为所有二进制位都是 1。因为目前一个 1 都没有，所以在所有位置上，模 3 的结果都为 0。
```

对于二进制表示的第 k 个位置（下面都是讨论某一个位置，反正所有位置的规则是一样的），我们可以用有序数组 (a, b, c) 来表示当前的状态。初始计数状态可以记作 (1, 0, 0)。  
在模 3 的加法中，0 + 1 = 1, 1 + 1 = 2, 2 + 1 = 0。据此容易看出，状态转移规则为：

* 如果当前处理的数为 0，则旧状态维持不变。
* 如果当前处理的数为 1，则更新计数状态：(1, 0, 0)->(0, 1, 0); (0, 1, 0)->(0, 0, 1); (0, 0, 1)->(1, 0, 0)，如此不断循环。

由状态转移规则，可以看出，对于 zero 来说，新状态是 1 的两个可能分别为：

* 旧状态的 zero 已经是 1，而且当前处理的数为 0；
* 旧状态的 two 是 1，而且当前处理的数为 1，所以更新状态之后（进位） zero 变为 1。

可以看出，实际上对于 one 和 two 来说，这个规律完全是类似的，因为在模 3 加法下，他们构成了一个循环，相互的地位是平等的。
但是这里有一个坑：如果直接根据这个状态转移规则写代码，会出现错误，因为在利用逻辑表达式更新完 zero 和 one 的状态之后，two 要更新状态，需要用到 one 的旧状态，但是 one 的旧状态已经没有了！这时候就需要引入一个临时变量 temp 来暂存 one 的旧状态。
于是代码为：

```
temp = zero; //这里用的另外一个逻辑：先计算 zero 的新状态，计算之前先用 temp 储存 zero 旧状态。计算 zero 之后，用过了 two，那么 two 的旧状态就没有用了，接着计算 two 的新状态。最后算 one。
zero = (zero & ~num) | (two & num);
two = (two & ~num) | (one & num);
one = (one & ~num) | (temp & num);
```

所有 num 都参与运算后，最终 one 储存的便是要求的答案。  
然而这道题显然没有到此为止。即使不算上临时变量，我们也用了整整三个变量储存三个状态，但是众所周知，三个二进制变量每一位都有两个状态，一共可以表示八个 ~~卦象~~ 状态，这是极大的浪费。  
所以容易想到，我们可以直接用两个变量储存计数状态：初始状态为 (0, 0)，然后是 (0, 1)，然后是 (1, 0)，然后循环。这样就实现了记录模 3 加法的状态。  
然后咧？
